## DNS에서 IP주소 찾기

### 1. 소켓라이브러리가 IP주소를 찾는 기능을 제공한다.

DNS서버를 조회한다는 것은 DNS서버에 조회 메세지를 보내고 거기에서 반송되는 응답 메세지를 받는다는 것입니다.
이것은 DNS서버에 클라이언트로서 동작한다고 말할 수 있습니다.
**DNS클라이언트에 해당하는 것을 DNS리졸버 또는 리졸버라고 부릅니다.**
리졸버의 실체는 **소켓 라이브러리**에 들어있는 부품화된 프로그램인데,
**소켓 라이브러리는 OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것입니다.**
리졸버는 그 속에 들어있는 프로그램들의 하나입니다.

### 2. 리졸버를 이용하여 DNS 서버를 조회한다.
소켓 라이브러리에 들어있는 프로그램은 부품화되어있고, 애플리케이션에서 간단히 호출하여 이용할 수 있습니다.
구체적으로 말해서 브라우저 등의 애플리케이션 프로그램을 만들 때 리졸버의 프로그램명(`gethostbyname`)과 웹 서버의 이름(도메인명)을
쓰기만 하면 리졸버를 호출할 수 있습니다. 
```c
  ThisIsApp(){
    ...
    <메모리 영역> = gethostmyname("kde6260.co.kr") // 메모리 영역에 서버의 IP주소가 기입됩니다. 
    ...
    <HTTP 메세지 송신>
  }
```

이렇게 리졸버를 호출하면 리졸버가 DNS서버에 조회 메세지를 보내고 DNS서버로부터 응답메세지가 돌아옵니다.
리졸버는 응답메세지에서 IP주소를 추출하여 브라우저에서 지정한 메모리 영역에 기록합니다.
이 작업이 실행되면서 도메인명으로 DNS로부터 IP주소를 조회하는 동작은 끝납니다.
브라우저는 웹 서버에 메세지를 보낼 때 이 메모리영역에서 IP주소를 추출하여 HTTP의 리퀘스트 메세지와 함께 
OS에게 건네줌으로써 송신을 의뢰할 뿐입니다.

### 3. 리졸버의 내부 작동
애플리케이션에서 호출된 리졸버가 어떻게 작동하는지를 간단히 살펴보겠습니다. 

```c
애플리케이션 프로그램(웹 브라우저){
  ...
  <메모리 영역> = gethostmyname("kde6260.co.kr") // 1)
  ...
}

소켓 라이브러리{
  gethostbyname(){
    DNS서버로 보낼 메세지를 만든다. // 2)
    메세지를 DNS서버로 보낸다. // 3)
    DNS서버로부터 돌아온 응답메세지를 수신한다. //6)
    응답 메세지에서 IP 주소를 추출하여 <메모리영역>에 저장하고 애플리케이션으로 돌아간다. // 7)
  }
  
OS 내부의 프로토콜 스택{
   UDP 메세지 송신{ ... } // 4)
   UDP 메세지 수신{ ... } // 5)
 }
}
```
리졸버의 메세지 송/수신 동작은 리졸버가 스스로 실행하는 것이 아니라 OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰합니다.
리졸버도 브라우저와 같이 네트워크를 통해 데이터를 송/수신하는 기능이 없기 때문입니다. 
**프로토콜 스택은 OS에 내장된 네트워크 제어용 소프트웨어입니다.** 프로토콜 드라이버, TCP/IP 소프트웨어라고도 불립니다.
리졸버가 프로토콜 스택을 호출하면 제어가 프로토콜 스택으로 넘어가고 프로토콜 스택이 메세지를 보내는 동작을 실행하여 LAN어댑터를 통해 
메세지가 DNS서버로 전송됩니다. DNS서버로부터 돌아온 응답메세지는 다시 프로토콜 스택을 경유하여 리졸버에게 건네지고, 리졸버에서
IP주소를 추출하여 애플리케이션 프로그램에게 전달합니다.

### 4. 프로토콜 스택에게 메세지 송신을 의뢰한다.
OS에 내장된 프로토콜 스택에게 메세지 송신을 의뢰할 때는 소켓 라이브러리의 프로그램 부품을 결정된 순번대로 호출합니다.
각 단계를 하나씩 짚어보기에 앞서 데이터 송/수신 동작 전체를 조감해보겠습니다.
![](https://s3.ap-northeast-2.amazonaws.com/kde6260/%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%8A%A4%ED%83%9D.jpg)
데이터를 송/수신하는 컴퓨터 사이에 데이터의 통로 같은 것이 있고, 이것을 통해 데이터가 흐르면서 상대측에 도착합니다.
통로는 파이프와 비슷하게 생겼다고 할 수 있습니다. 한쪽에서 파이프에 데이터를 쏟아부으면 파이프 안을 통해 반대쪽까지 흘러가고,
거기서 데이터를 추출할 수 있습니다. 어느 쪽에서 먼저 쏟는지와 상관없이 양방향으로 데이터를 보낼 수 있습니다.
중요한 점은 이 파이프가 항상 존재하는 것처럼 보이지만 송/수신 동작을 하기위해서는 파이프를 연결하는 동작이 필요합니다.
<br><br>
**파이프의 양 끝에는 데이터의 출입구가 있는데, 이 출입구를 소켓이라고 부릅니다.** 파이프로 데이터를 주고받기 위해서는 이 소켓을
만들고 연결하는 과정이 필요합니다. 먼저 서버에서 소켓을 만들고 소켓에 클라이언트가 자신의 파이프를 연결하기를 기다립니다.
클라이언트 측에서는 소켓을 만들고 소켓에서 파이프를 늘려 서버의 소켓에 연결하는 것입니다. <br>
파이프를 통해 데이터의 송/수신이 완료되고 나면 연결했던 파이프가 분리됩니다. 파이프를 연결할 때는 클라이언트 측에서 서버를 향해 연결했지만,
파이프를 분리할 때는 어느 쪽에서 분리해도 무관합니다. <br>
소켓을 이용한 데이터 송/수신 동작은 몇 단계로 나뉘어 있는데 다음의 4가지 단계로 요약할 수 있습니다.

1. 소켓을 만든다.(소켓 작성)
2. 서버 측의 소켓에 파이프를 연결한다. (접속)
3. 데이터를 송/수신한다. (송/수신)
4. 파이프를 분리하고 소켓을 말소한다. (연결 끊기)

이 단계에 따라 소켓 라이브러리 안의 프로그램을 호출하여 데이터의 송/수신 동작을 수행합니다. **앞의 4가지 단계를 실행하는 것은 OS내부의
프로토콜 스택입니다. 웹 브라우저 등의 애플리케이션은 스스로 파이프를 연결하거나 데이터를 보내지 않고 프로토콜 스택에 의뢰하여 파이프를 연결하고
데이터를 송/수신합니다.**  
----------------------------------------------------------------------------------------------------------
출처 : [성공과 실패를 결정하는 1%의 네트워크 원리](https://books.google.co.kr/books/about/1_%EC%9D%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%9B%90%EB%A6%AC_2ND_EDITION.html?id=edmSPgAACAAJ&source=kp_cover&redir_esc=y)
