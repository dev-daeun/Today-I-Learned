# 관계를 표현하는 모델 필드
* ForeignKey
* OneToOneField
* ManyToManyField

## 1:N 관계는 ForeignKey로 표현
외래키 필드를 만들 때는 1:N 관계에서 N측에 해당하는 모델에 `ForeignKey`필드를 정의합니다.

`ForeignKey(to, on_delete)`

* `to` : 대상 모델을 지정합니다. 자기 참조는 `'self'`로 설정합니다.
* `on_delete`: 참조하고 있는 대상이 삭제될 경우 행동을 지정합니다.

1. PROTECT: `ProtectedError`(`IntegrityError`의 자식클래스)를 발생시키고 삭제를 방지합니다.
2. SET_NULL: `null`로 대체합니다. 이 때 `null=True`옵션이 `ForeignKey`필드에 반드시 주어져야 합니다.
3. SET(func): 대체할 함수 `func`을 인자로 넘깁니다. `func`을 호출한 값으로 설정됩니다.
4. DO_NOTHING: 아무런 액션도 취하지 않습니다. 데이터베이스에 따라 오류가 발생할 수 있습니다.

	
```python
from django.db import models
from django.utils import timezone
from django.conf import settings


class Post(models.Model):
    # settings.AUTH_USER_MODEL: 장고에서 기본적으로 제공하는 User모델
    author = models.ForeignKey(
         settings.AUTH_USER_MODEL,
         on_delete=models.CASCADE,
     )
    title = models.CharField(
        max_length=100,
    )
    pub_date = models.DateTimeField(
        default=timezone.now(),
    )
  

class Comment(models.Model):
    post = models.ForeignKey(
        Post,
        on_delete=models.CASCADE,
    )
    message = models.TextField()
    
# post, comment 인스턴스 생성
post = Post.objects.create(title='Hi!')
c1, c2 = [Comment.objects.create(post=post, message=msg) for msg in ['Hi.', 'Me too.']]
```
`Post`와 `Comment`는 1:N 관계입니다. 
N에 해당하는 모델에서 1에 해당하는 모델을 참조할 때는 `<클래스이름의 소문자>`로 표현합니다.

```python
c1.post.title. # Hi.
c2.post.title. # Me too.
```

1에 해당하는 모델에서 N을 참조할 때는 `<클래스이름>_set`으로 표현합니다. 위의 예시에서는 `Post`가 `Comment`를 여러개 가질 수 있으므로 `comment_set`으로 표현됩니다.

```python
post.comment_set.all()  
# <QuerySet [<Comment: Comment object (3)>, <Comment: Comment object (4)>]>
```

N에 해당하는 모델의 `ForeignKey`에 `related_name`속성으로 매니저 이름을 바꿀 수 있습니다.

```python
class Comment(models.Model):
    post = models.ForeignKey(
        Post,
        on_delete=models.CASCADE,
    	 related_name = 'comments',
    )
    message = models.TextField()
    
post.comments.all()
# <QuerySet [<Comment: Comment object (3)>, <Comment: Comment object (4)>]>
```
한 가지 주의할 점이 있습니다. 여러개의 앱에서 동일한 이름의 `Post`모델이 있고 각 `Post`모델은 `auth.User`를 참조한다고 가정해봅시다. `related_name`의 디폴트 값은 `<클래스이름 소문자>_set`이므로 `User`입장에서 `Post`모델을 역참조 할 때 모두 동일하게 `post_set`으로 참조할 것입니다.
이 경우 `User`는 어떤 앱의 `Post`모델을 참조하는지 알 수 없게 되므로 충돌이 발생합니다. 
<br>
이를 방지하기 위해 django공식문서에서는 `related_name`을 아래와 같이 명명하기를 권장합니다.

```python
from django.db import models

class Post(models.Model):
     author = models.ForeignKey(
         settings.AUTH_USER_MODEL,
         on_delete=models.CASCADE,
         related_name='%(app_label)s_%(class)s_related',
     )

    class Meta:
        abstract = True
```
* `%(class)s` is replaced by the lower-cased name of the child class that the field is used in.
* `%(app_label)s` is replaced by the lower-cased name of the app the child class is contained within. Each installed application name must be unique and the model class names within each app must also be unique, therefore the resulting name will end up being different.
<br>(같은 추상클래스를 상속받는 여러개의 모델의 `related_name`을 설정할 때 적용하는 방법이지만, 위에서 언급한 주의사항을 해결할 때도 적용할 수 있습니다.)

### limit_choices_to 

`ForeignKey`에 `limit_choices_to`옵션을 지정하면 폼을 통한 위젯에서 선택항목을 제한할 수 있습니다.

```python
class ExtendedUser(auth.User):
	is_staff = models.BooleanField(
		default=False,
	)
	
class Reports(models.Model):
	staff_member = models.ForeignKey(
		ExtendedUser,
		on_delete=models.CASCADE,
		limit_choices_to={'is_staff': True},
	)
```
위의 예시에서 `Reports`는 `is_staff`가 `True`인 `ExtendedUser`만을 참조할 수 있습니다.
`limit_choices_to`는 딕셔너리 또는 Q객체를 통해 일괄적으로 지정을 할 수 있고, 함수를 넘김으로써 조건에 따라 딕셔너리나 Q객체를 다르게 지정할 수도 있습니다. 

## 1:1 관계는 OneToOneField로 표현
`OneToOneField`는 어떤 모델 A에 종속적인 모델 B의 필드로 지정합니다. 예를 들어, User와 Profile은 1:1관계이지만 User가 삭제되면 Profile도 삭제되므로 Profile에 `OneToOneField`를 지정하는게 바람직합니다. 아래의 예시에서는 `Place`에 종속적인 `Restaurant`에 `OneToOneField`를 지정했습니다.

```python
# Place optionally can be a Restaurant.
class Place(models.Model):
    name = models.CharField(
        max_length=50,
    )
    address = models.CharField(
        max_length=80,
    )

    def __str__(self):
        return f'{self.name} the place.'


class Restaurant(models.Model):
    # place_id가 곧 기본키.
    place = models.OneToOneField(
        Place,
        on_delete=models.CASCADE,
        primary_key=True,
    )
    serve_hot_dogs = models.BooleanField(
        default=False,
    )
    serve_pizza = models.BooleanField(
        default=False,
    )

    def __str__(self):
        return f'{self.place.name} the restaurant.'


place = Place.objects.create(name='신전떡볶이', address='성북구 돈암동')
restaurant = Restaurant.objects.create(place=place)

restaurant.place  # <Place 신전떡볶이 the place.>
place.restaurant  # <Restaurant 신전떡볶이 the restaurant.>

place2 = Place.objects.create(name='궤도에 오르다', address='성북구 돈암동')
place2.restaurant. # Restaurant.DoesNotExist 
```
여기서  `Place`모델은 `Restaurant`을 필수로 가지지 않기 때문에 `place2`의 경우 예외가 발생합니다.
