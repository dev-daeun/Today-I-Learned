## Heap Tree

힙 트리는 완전이진트리의 한 종류입니다.

> 완전(Complete)이진트리<br>
> * 노드를 추가할 때 단말의 왼쪽부터 노드를 삽입하는 트리. 
> * 포화(Perfect)이진트리도 완전이진트리에 포함된다.


힙 트리는 최대 힙(Max Heap)과 최소 힙(Min Heap) 2가지로 분류됩니다. 
* **최소 힙** : 루트 노드가 언제나 최솟값을 가지고, 부모 노드가 자식 노드보다 작은 값을 가지는 트리.
* **최대 힙** : 루트 노드가 언제나 최댓값을 가지고, 부모 노드가 자식 노드보다 큰 값을 가지는 트리.

![](https://i2.wp.com/www.techiedelight.com/wp-content/uploads/2016/11/Min-Max-Heap.png?fit=738%2C430)

이렇게 봤을 때, 최소 힙과 최대 힙은 각각 어떤 서브트리도 항상 최소 힙과 최대 힙을 만족하므로,<br>
두 트리는 재귀적으로 정의가 가능합니다. <br>
> 같은 레벨에 있는 노드들의 대소비교에 따른 순서는 정해지지 않습니다. 부모 노드와의 대소에 의해서만 정렬되어 있는 것입니다.


## 연산
힙트리에서 가능한 연산은 다음과 같습니다.
* empty heap 생성
* 노드의 삽입
* 노드의 삭제 (최소/최대 힙에서 루트 노드를 반환하고 삭제)

정렬 알고리즘 중에 하나인 힙 정렬은 힙 트리에서 추가/삭제 연산을 통해 정렬합니다.<br>
노드의 추가/삭제의 시간복잡도는 각각 `logN`이므로 힙 정렬의 시간복잡도 또한 `logN`입니다.


## 구조 
![](http://www.cse.hut.fi/en/research/SVG/TRAKLA2/tutorials/heap_tutorial/KekoTRAKLA-89_1.gif)<br>
힙트리는 배열로 구현합니다.(c++과 java의 경우 우선순위 큐로 구현할 수 있습니다.)<br>
배열에서 인덱스가 1인 원소는 곧 루트이며, 왼쪽에서 오른쪽 순서로 노드들을 표현합니다.<br>
완전이진트리이므로 어떤 노드가 배열의 `m`번째 원소라고 했을 때, <br>
* `m`번째 노드의 왼쪽 노드  = `2m`번째 원소
* `m`번째 노드의 오른쪽 노드 = `2m+1`번째 원소
* `m`번째 노드의 부모 노드 = `m/2`번째 원소

를 만족합니다. 


## 노드의 추가/삭제 
> 노드를 추가할 때 아래에서 위로 비교하여 바꿔나간다.

![](http://venus.cs.qc.cuny.edu/~mfried/cs313/heapinsertion.png)

최소 힙을 예로 들어보겠습니다. 추가할 노드가 단말에 들어오면 부모노드와 값을 비교합니다. <br>
들어온 노드의 값이 더 작을 경우, 부모노드와 값을 바꾸게 됩니다. <br>
이렇게 최소 힙의 조건을 만족할 때까지 부모노드와 값을 비교하여 자리를 바꿔나가는데, <br> 
부모를 타고올라가므로 아래에서 위로 노드의 위치가 바뀌게 됩니다.<br>
이 때 노드를 삽입하는 데 필요한 최대 횟수는 `logN`(트리의 높이)이므로 노드삽입의 최악의 시간복잡도는 `logN`입니다.

## 
> 노드를 삭제할 때 위에서 아래로 비교하여 바꿔나간다.

![](http://venus.cs.qc.cuny.edu/~mfried/cs313/heapdeletion.png)

노드를 삭제할 때는 반대로 루트 노드를 `pop`하고난 뒤 맨 끝에 있는 노드를 루트로 올려보냅니다. <br>
루트로 옮겨진 노드와 자식노드의 값을 비교하면서 자식노드보다 큰 값을 가지고 있을 경우 자식노드와 값을 바꾸게 됩니다.<br>
최소 힙의 조건을 만족할 때까지 자식노드와 값을 비교하여 자리를 바꿔나가는데,<br>
자식을 타고 내려가므로 위에서 아래로 노드의 위치가 바뀌게 됩니다.<br>
이 때 노드를 삭제하는 데 필요한 최대 횟수는 `logN`(트리의 높이)이므로 노드삭제의 최악의 시간복잡도는 `logN`입니다.
